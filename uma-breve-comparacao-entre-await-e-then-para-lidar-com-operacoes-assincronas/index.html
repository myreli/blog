<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale = 1.0, maximum-scale=1.0">
    <meta name="author" content="Myreli <myreli@proton.me>">

    <title> | noted.myreli.dev</title>

    <link rel="stylesheet" href="https://unpkg.com/prismjs@1.28.0/themes/prism.min.css">
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.classless.min.css">
    <style>
        :root {
            --spacing: .75rem;
        }

        html,
        body {
            overflow-x: hidden;
        }

        button {
            --background-color: transparent;
            --color: var(--primary);
        }
    </style>
</head>

<body>
    <header>
        <nav>
            <ul>
                <li>
                  <a href="/">
                    <code>noted.myreli.dev</code>
                  </a>
                </li>
            </ul>
            <ul><li><a href="/about/">Sobre</a></li>
<li><a href="/">Posts</a></li>
<li><a href="/tags/">Tags</a></li></ul>
        </nav>
        <hgroup>
            <h1 id=""></h1>
            <h2 id=""></h2>
        </hgroup>
        <hr>
    </header>
    <main>
        
<h1 id="uma-breve-comparacao-entre-await-e-then-para-lidar-com-operacoes-assincronas">üåø Uma breve compara√ß√£o entre await e then para lidar com opera√ß√µes ass√≠ncronas</h1>

<p></p><p dir="auto"></p><p dir="auto"></p><p dir="auto"><mark></mark></p><p dir="auto">async + await vs then e legibilidade de c√≥digo.</p><p dir="auto"><mark><br></mark></p><p dir="auto"><mark>Em constru√ß√£o!</mark></p><p dir="auto">Existe uma conversa frequente nos f√≥runs de Node.js acerca de como lidar com fun√ß√µes ass√≠ncronas. Ainda que <code>async</code> e <code>then</code> nos fornecem a mesma funcionalidade para lidar com c√≥digo ass√≠ncrono em JavaScript, ambas s√£o distintas em seu funcionamento e efeitos colaterais.</p><hr dir="auto"><p dir="auto"><em>Essa n√£o √© uma introdu√ß√£o as promises ou programa√ß√£o ass√≠ncrona, apenas devaneios sobre formas de lidar com o resultado dessas opera√ß√µes. Aqui est√£o excelentes materiais para aprender sobre recursos de programa√ß√£o ass√≠ncrona no JavaScript:</em></p><ul dir="auto"><li dir="auto"><p dir="auto"><a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Using_promises" rel="noopener nofollow" target="_blank">https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Using_promises</a></p></li><li dir="auto"><p dir="auto"><a href="https://web.dev/i18n/pt/promises/" rel="noopener nofollow" target="_blank">https://web.dev/i18n/pt/promises/</a></p></li><li dir="auto"><p dir="auto"><a href="https://developer.mozilla.org/pt-BR/docs/Learn/JavaScript/Asynchronous" rel="noopener nofollow" target="_blank">https://developer.mozilla.org/pt-BR/docs/Learn/JavaScript/Asynchronous</a></p></li></ul><hr dir="auto"><p dir="auto">Trabalhando com Node.js (JavaScript) voc√™ provavelmente j√° se deparou com esses dois tipos de c√≥digo:</p><ol dir="auto"><li dir="auto"><p dir="auto">Requisi√ß√£o a API constru√≠da pelo time do <code>then</code></p></li></ol><pre dir="auto"><code class="language-javascript">fetch("https://emojihub.herokuapp.com/api/random")
    .then(response =&gt; response.json())
    .then(data =&gt; console.info(data))</code></pre><ol start="2" dir="auto"><li dir="auto"><p dir="auto">Requisi√ß√£o a API constru√≠da pelo time do <code>async/await</code></p></li></ol><pre dir="auto"><code class="language-javascript">const response = await fetch("https://emojihub.herokuapp.com/api/random")

const data = await response.json()

console.info(data)</code></pre><p dir="auto">Ambas resultam na mesma coisa: um emoji retornado randomicamente pela API e exibido no console. Mas cada API tem seus objetivos e seus respectivos casos de uso, e a sem√¢ntica de cada um √© diferente.</p><p dir="auto">Defendo que n√£o existe bala de prata e cada recurso tem sua raz√£o de ser, ent√£o esse rascunho n√£o serve para dizer qual √© melhor, mas sim comparar ambos e ajudar na escolha, al√©m de compartilhar minha prefer√™ncia do ponto de vista da legibilidade.</p><h1 dir="auto" id="historia"><strong>Hist√≥ria</strong></h1><p dir="auto">Para que o pr√≥ximo t√≥pico fa√ßa sentido, vou come√ßar traduzindo cada uma das implementa√ß√µes:</p><ol dir="auto"><li dir="auto"><p dir="auto">Utilizando <code>then</code>, estamos essencialmente:</p></li></ol><pre dir="auto"><code class="language-javascript">'BUSCAR O EMOJI NA API'
    ENT√ÉO 'TRANSFORMAR A RESPOSTA EM JSON'
    ENT√ÉO 'IMPRIMIR OS DADOS'</code></pre><ol dir="auto"><li dir="auto"><p dir="auto">Utilizando <code>await</code>, estamos essencialmente:</p></li></ol><pre dir="auto"><code class="language-javascript">RESPOSTA = (AGUARDE) 'BUSCAR O EMOJI NA API'

DADOS = (AGUARDE) 'TRANSFORMAR A RESPOSTA EM JSON'

'IMPRIMIR OS DADOS'</code></pre><p dir="auto">A implementa√ß√£o sozinha pode parecer pouca diferen√ßa, mas no segundo caso o c√≥digo l√™ mais natural, muito semelhante ao s√≠ncrono. Enquanto o primeiro depende de bastante compreens√£o do <a href="https://subscription.packtpub.com/book/web-development/9781783287314/1/ch01lvl1sec10/the-callback-pattern" rel="noopener nofollow" target="_blank">https://subscription.packtpub.com/book/web-development/9781783287314/1/ch01lvl1sec10/the-callback-pattern</a> e corre o risco do <a href="http://callbackhell.com/" rel="noopener nofollow" target="_blank">http://callbackhell.com/</a>, caso seja mal implementado.</p><p dir="auto">Para al√©m da naturalidade, cada formato tem objetivo diferente e internalidades diferentes. Apesar de parecer apenas um a√ß√∫car sint√°tico, <code>await</code> implica em outras diferen√ßas tamb√©m.</p><p dir="auto">E esse √© um motivo hist√≥rico, em linha do tempo:</p><ol dir="auto"><li dir="auto"><p dir="auto">Node.js foi criado profundamente atrelado ao Padr√£o Callback, que permitia a utiliza√ß√£o de c√≥digo ass√≠ncrono</p></li><li dir="auto"><p dir="auto">Foram criadas as <em>promises</em> e as novas APIs de <code>then/catch/finally</code> que permitiram minimizar o <em>callback hell</em></p></li><li dir="auto"><p dir="auto">Finalmente foram criadas as <em>fun√ß√µes ass√≠ncronas</em>, que trouxeram o <code>async/await</code> e permitiram o c√≥digo mais leg√≠vel e natural (<a href="https://developers.google.com/web/fundamentals/primers/async-functions" rel="noopener nofollow" target="_blank">https://developers.google.com/web/fundamentals/primers/async-functions</a>)</p></li></ol><p dir="auto">Apesar de n√£o serem sempre recursos concorrentes e terem seus pr√≥prios casos de uso, a nova sintaxe √© uma evolu√ß√£o levando em conta diversos dos problemas anteriores. Por isso, para alguns casos ela claramente ser√° mais compreens√≠vel, porque surgiu em um contexto diferente ‚Äî de resolver problemas anteriores.</p><p dir="auto">O mesmo vale para as novas APIs de manipula√ß√£o de cole√ß√µes ‚Äî <code>map</code>, <code>filter</code>,<code>reduce</code> ‚Äî nenhum deles substitui o bom e velho <code>for</code> ou ainda o <code>while</code>, apenas resolvem problemas espec√≠ficos.</p><h1 dir="auto" id="compreensibilidade"><strong>Compreensibilidade</strong></h1><p dir="auto">Escreverei pouco sobre este t√≥pico porque o c√≥digo fala mais do que mil palavras. E porque existem materiais melhores escritos sobre isso (como esse da Google <a href="https://developers.google.com/web/fundamentals/primers/async-functions" rel="noopener nofollow" target="_blank">https://developers.google.com/web/fundamentals/primers/async-functions</a> ou <a rel="noopener noreferrer nofollow" href="https://">esse da MDN </a><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises" rel="noopener nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises</a>).</p><p dir="auto">Naturalmente (ao menos na nossa regi√£o) fazemos a leitura de cima para baixo e da esquerda para a direita. E √© isso que o c√≥digo expressa:</p><pre dir="auto"><code class="language-javascript">console.log("#1");

await something();

console.log("#2");

console.log("#3");</code></pre><p dir="auto">J√° utilizando <code>then</code>, n√£o podemos garantir que o c√≥digo a seguir ser√° executado nessa ordem, mas sim que vai acontecer na ordem que for mais perform√°tica:</p><pre dir="auto"><code>console.log("#1");

something().then(() =&gt; { 
    console.log("#3? (or #2)");
})

console.log("#2? (or #3)");</code></pre><p dir="auto">Para garantir a ordem, seria necess√°rio encadear a execu√ß√£o a resolu√ß√£o da <em>Promise</em>, causando aninhamento e poss√≠vel quebra de sem√¢ntica:</p><pre dir="auto"><code>console.log("#1");

something().then(() =&gt; { 
    console.log("#2");
}).finally(() =&gt; {
    console.log("#3");
})</code></pre><p dir="auto">C√≥digo limpo √© c√≥digo limpo em qualquer lugar e com qualquer padr√£o, ent√£o sem aninhar seus <em>thens</em>. Em qualquer n√≠vel, sempre evite o <strong>callback hell: </strong><a href="https://ibb.co/DkMWQfq" rel="noopener nofollow" target="_blank">https://ibb.co/DkMWQfq</a>.</p><h1 dir="auto" id="performance">Performance</h1><p dir="auto">Hoje em dia, o <code>async/await</code> √© mais r√°pido que as outras op√ß√µes, e muito mais r√°pido que implementa√ß√µes manuais de promise. Isso √© gra√ßas ao <a href="https://v8.dev/blog/fast-async" rel="noopener nofollow" target="_blank">https://v8.dev/blog/fast-async</a>, uma implementa√ß√£o da V8 que se aproveitou dos recursos para evitar o <em>overhead </em>que era causado pela <em>promise </em>extra no <code>await</code> .</p><p dir="auto">De todo modo, sempre priorize realizar em ‚Äúparalelo‚Äù processamentos que n√£o s√£o bloqueantes e dependentes entre si e aguardar por todos de uma vez s√≥. O <a rel="noopener noreferrer nofollow" href="https://">promise.all</a> √© um exemplo de recurso que possibilita isso, e pode ser utilizado em qualquer uma das maneiras. (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a>)</p><h1 dir="auto" id="tratamento-de-erros">Tratamento de Erros</h1><p dir="auto">Al√©m de possibilitar o tratamento de erros mais familiar (<code>try/catch</code>), a V8 trabalhou em um recurso poderos√≠ssimo para o tratamento de erros com <code>async/await</code>: Zero-cost async stack traces (<a href="https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q/edit#heading=h.e6lcalo0cl47" rel="noopener nofollow" target="_blank">https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q/edit#heading=h.e6lcalo0cl47</a>). Isso significa que o rastreamento de erro contempla as informa√ß√µes do c√≥digo s√≠ncrono e ass√≠ncrono, resolvendo uma dor forte do padr√£o de <em>callbacks</em> ou do <code>then/catch</code>, que era detectar a origem de erros n√£o capturados quando surgiam de c√≥digo ass√≠ncrono.</p><p dir="auto">Por outro lado, como JavaScript n√£o possui <em>catchs</em> condicionais, o tratamento espec√≠fico de exce√ß√£o pode ser mais verboso, enquanto temos o par <code>then/catch</code> que pode especificar por cada opera√ß√£o ass√≠ncrona.</p><p dir="auto">Para se aprofundar nas conven√ß√µes de tratamento de erro, veja:</p><ul dir="auto"><li dir="auto"><p dir="auto"><a href="https://nodejs.org/en/knowledge/errors/what-are-the-error-conventions/" rel="noopener nofollow" target="_blank">https://nodejs.org/en/knowledge/errors/what-are-the-error-conventions/</a></p></li><li dir="auto"><p dir="auto"><a href="https://nodejs.dev/learn/error-handling-in-nodejs" rel="noopener nofollow" target="_blank">https://nodejs.dev/learn/error-handling-in-nodejs</a></p></li><li dir="auto"><p dir="auto"><a href="https://www.honeybadger.io/blog/errors-nodejs/" rel="noopener nofollow" target="_blank">https://www.honeybadger.io/blog/errors-nodejs/</a></p></li><li dir="auto"><p dir="auto"><a href="https://mathiasbynens.be/notes/async-stack-traces" rel="noopener nofollow" target="_blank">https://mathiasbynens.be/notes/async-stack-traces</a></p></li></ul><h1 dir="auto" id="afinal-qual-forma-e-a-melhor">Afinal, qual forma √© a melhor?</h1><p dir="auto">Nenhuma. Cada uma pode ter um caso de uso mais ou menos adequado, de acordo com o contexto.</p><p dir="auto">Assim como n√£o devemos encadear v√°rios condicionais (<code>if</code>) tamb√©m n√£o dever√≠amos encadear v√°rios resolvedores de promessas (<code>then</code>). E assim como n√£o dever√≠amos implementar um complexo padr√£o de projeto para resolver uma valida√ß√£o de sim ou n√£o, n√£o dever√≠amos criar uma fun√ß√£o para utilizar <code>await</code> quando o padr√£o de <em>callback</em> resolveria.</p><p dir="auto">Por causa do ganho em compreensibilidade e das possibilidades de melhoria em performance que chegaram com a sintaxe <code>async/await</code>, a discuss√£o ainda vem evoluindo para que <code>await</code> possa ser utilizado tamb√©m em n√≠vel de m√≥dulos.</p><p dir="auto">As propostas originais mencionadas servem como contexto para o problema do <em>callback hell </em>e as vantagens observadas com a nova sintaxe:</p><ul dir="auto"><li dir="auto"><p dir="auto"><a href="https://tc39.es/proposal-async-await/" rel="noopener nofollow" target="_blank">https://tc39.es/proposal-async-await/</a></p></li><li dir="auto"><p dir="auto"><a href="https://tc39.es/proposal-top-level-await/" rel="noopener nofollow" target="_blank">https://tc39.es/proposal-top-level-await/</a></p></li></ul><p dir="auto">Isso n√£o demonstra que ele seja melhor, mas que foi amplamente adotado e o uso vem crescendo. As pessoas olhariam estranho para um c√≥digo cheio de <code>then</code> encadeado sendo que temos uma API muito mais limpa para lidar com isso.</p><p dir="auto">E as pessoas tamb√©m olhariam estranho para uma lista de <em>awaits </em>dentro de uma mesma fun√ß√£o porque isso pode estar criando um bloqueio por for√ßar o comportamento s√≠ncrono, principalmente quando dentro de <em>loops</em>. <em>(off-topic: Se voc√™ tem trabalhando com v√°rias opera√ß√µes encadeadas, recomendo fortemente o estudo de streams. Especialmente as pipelines </em><a href="https://nodejs.org/api/stream.html#streampipelinesource-transforms-destination-callback" rel="noopener nofollow" target="_blank">https://nodejs.org/api/stream.html#streampipelinesource-transforms-destination-callback</a><em>)</em></p><p dir="auto">Lembrando do Fowler:</p><blockquote dir="auto"><p dir="auto">Any fool can write code that a computer can understand. Good programmers write code that humans can understand.</p></blockquote><p dir="auto">No fim, o melhor para a aplica√ß√£o √© n√£o bloquear o <em>event loop</em>. A forma como isso ser√° codificado depende muito mais do c√≥digo e das pessoas que v√£o ler ele ‚Äî pessoalmente vejo que a sintaxe <code>async/await</code> costuma atender a maioria dos casos comuns, al√©m de ser compat√≠vel com a especifica√ß√£o de <em>async iterators</em> (<a href="https://tc39.es/proposal-async-iteration/" rel="noopener nofollow" target="_blank">https://tc39.es/proposal-async-iteration/</a>).</p><p dir="auto">Isso n√£o exime de utilizar <em>callbacks</em>, eles s√£o core do Node (<a href="https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/" rel="noopener nofollow" target="_blank">https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/</a>), ainda que eles pr√≥prios tratem <code>async/await</code> como a alternativa moderna para lidar com assincronismo (<a href="https://nodejs.dev/learn/modern-asynchronous-javascript-with-async-and-await" rel="noopener nofollow" target="_blank">https://nodejs.dev/learn/modern-asynchronous-javascript-with-async-and-await</a>).</p><p dir="auto">Al√©m disso, vale mencionar que a V8, o motor que faz a magica acontecer e JS executar no Back-End com Node.js, aconselha (1) a utiliza√ß√£o de <code>async/await</code> em vez de <em>promises</em> escritas manualmente pelos ganhos em performance e (2) a utiliza√ß√£o das implementa√ß√µes nativas de <em>promise</em> em vez de bibliotecas pelos outros benef√≠cios mencionados anteriormente, na se√ß√£o de performance.</p><h1 dir="auto" id="nao-bloqueie-o-event-loop">‚ÄúN√£o bloqueie o <em>Event Loop</em>‚Äù</h1><p dir="auto">Afinal, por que tudo isso? <em>(em homenagem ao meu amigo que xingou Node.js dizendo que ler um arquivo em Java na aula de POO foi mais simples que entender o Event Loop)</em></p><p dir="auto">Quando algu√©m me questiona porque tantas APIs nativas do Node.js, ou mesmo as bibliotecas mais utilizadas, s√£o ass√≠ncronas e se n√£o seria mais simples elas simplesmente serem s√≠ncronas como em algumas outras linguagens, minha resposta gira em torno d√™: <em>‚ÄúN√£o bloqueie o Event Loop‚Äù.</em></p><p dir="auto">Node.js¬Æ √© descrito em sua pr√≥pria documenta√ß√£o como <em>‚Äúum ambiente de execu√ß√£o JavaScript ass√≠ncrono e orientado a eventos‚Äù</em> que utiliza um <em>‚Äúmodelo de I/O n√£o bloqueante‚Äù</em>. Na pr√°tica isso quer dizer muitas coisas, e a arquitetura do Node.js √© uma que vale estudar, mas podemos resumir em ‚Äún√£o bloqueie o <em>event loop</em>‚Äù porque essa √© a estrat√©gia para que ele seja n√£o bloqueante e orientado a eventos por padr√£o.</p><p dir="auto">O <em>event loop</em> nada mais √© do que a <em>thread</em> principal, e devemos mant√™-la livre de processos pesados para que ela se mantenha perform√°tica e segura. Em vez disso, enviamos tarefas pesadas para outras <em>threads</em> e lidamos com o resultado de forma ass√≠ncrona, atrav√©s de eventos.</p><p dir="auto">Por isso, para garantirmos nunca bloquear a <em>thread</em> principal, que tantas APIs nativas s√£o ass√≠ncronas por padr√£o, e assim deve ser com as SDKs e bibliotecas que utilizamos. Se n√£o √© ass√≠ncrono por padr√£o, torne-a. <strong><em>N√£o bloqueie o Event Loop</em></strong> :)</p><p dir="auto">Alguns recursos da pr√≥pria documenta√ß√£o para se aprofundar nesse tema e na arquitetura do Node.js:</p><ul dir="auto"><li dir="auto"><p dir="auto"><a href="https://nodejs.dev/learn" rel="noopener nofollow" target="_blank">https://nodejs.dev/learn</a></p></li><li dir="auto"><p dir="auto"><a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" rel="noopener nofollow" target="_blank">https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/</a></p></li><li dir="auto"><p dir="auto"><a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" rel="noopener nofollow" target="_blank">https://nodejs.org/en/docs/guides/dont-block-the-event-loop/</a></p></li></ul><hr dir="auto"><h1 dir="auto" id="conclusao">Conclus√£o</h1><p dir="auto">N√£o existe bala de prata, como tudo na tecnologia e na vida. Ambos s√£o recursos poderosos, assim como o pr√≥prio padr√£o callback e o ideal √© entender os dois para definir o mais adequado ao contexto ‚Äî afinal foram criados em contextos diferentes para resolver problemas diferentes.</p><p dir="auto">Quando estamos falando de tratamento de erros, legibilidade e desempenho, o <code>async/await</code> performa melhor, mas apenas isso n√£o o torna a solu√ß√£o ideal.</p><p dir="auto">Para se aprofundar nesse tema voc√™ pode ler mais nos materiais que eu utilizei como base para escrever:</p><ul dir="auto"><li dir="auto"><p dir="auto"><a href="https://mathiasbynens.be/notes/async-stack-traces" rel="noopener nofollow" target="_blank">https://mathiasbynens.be/notes/async-stack-traces</a></p></li><li dir="auto"><p dir="auto"><a href="https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q/edit" rel="noopener nofollow" target="_blank">https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q/edit</a></p></li><li dir="auto"><p dir="auto"><a href="https://tc39.es/ecma262/#await" rel="noopener nofollow" target="_blank">https://tc39.es/ecma262/#await</a></p></li><li dir="auto"><p dir="auto"><a href="https://tc39.es/ecma262/#sec-promise.prototype.then" rel="noopener nofollow" target="_blank">https://tc39.es/ecma262/#sec-promise.prototype.then</a></p></li><li dir="auto"><p dir="auto"><a href="https://github.com/tc39/ecma262/pull/1250" rel="noopener nofollow" target="_blank">https://github.com/tc39/ecma262/pull/1250</a></p></li><li dir="auto"><p dir="auto"><a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" rel="noopener nofollow" target="_blank">https://nodejs.org/en/docs/guides/dont-block-the-event-loop/</a></p></li></ul><hr dir="auto"><p dir="auto">Grat√≠ssima a voc√™ por ler at√© aqui. Espero que esse conte√∫do tenha agregado de alguma forma. ü§ó</p><p dir="auto">Se quiser conversar sobre o tema voc√™ pode me enviar um e-mail para <a rel="noopener noreferrer nofollow" href="mailto:myreli@duck.com">myreli@duck.com</a>, deixar uma mensagem no <a rel="noopener noreferrer nofollow" href="https://">Guestbook</a> ou ainda um <a target="_blank" rel="noopener noreferrer nofollow" href="https://listed.to/@myreli/tip">agradecimento</a>.</p><p dir="auto"><br></p><p dir="auto">***</p><p dir="auto"><br></p><p dir="auto"><span style="color: rgb(0, 0, 0); font-size: 17.5px;">üåø&nbsp;</span><span style="font-weight: bolder; color: rgb(0, 0, 0); font-size: 17.5px;">Budding</span><span style="color: rgb(0, 0, 0); font-size: 17.5px;">&nbsp;s√£o ideias que j√° revisei ou editei um pouco. Est√£o come√ßando a tomar forma, mas ainda precisam de refinamento.&nbsp;</span><a href="https://listed.to/@Myreli/the-garden" target="_blank">O que √© isso?</a></p><p dir="auto"><br></p><p dir="auto"><br><br></p>
<p></p>


        
            <span id="discussion-section">
                <button onclick="loadDiscussionSection()">ver coment√°rios</button>
            </span>
        
    </main>

    <footer>
        <article>
            <p>Quer receber atualiza√ß√µes trimestrais por e-mail? Sem spam.</p>
            <form action="https://buttondown.email/api/emails/embed-subscribe/myreli" method="post" target="popupwindow" onsubmit="window.open('https://buttondown.email/myreli', 'popupwindow')">
                <input type="email" name="email" placeholder="Digite seu e-mail" required="">
                <button type="submit">Receber atualiza√ß√µes</button>
            </form>
        </article>

        <p>
            Copyright ¬© <a href="https://myreli.dev">Myreli</a> 2023
        </p>
    </footer>
    <script>
        var HYVOR_TALK_WEBSITE = 545;
        var HYVOR_TALK_CONFIG  = {
            id: "false"
        }

        function loadDiscussionSection() {
          const discussions = document.getElementById('discussion-section')
          if (!discussions) return;

          discussions.children[0].setAttribute("aria-busy", true)

          const widget = document.createElement("div")
          widget.id = "hyvor-talk-view"

          const script = document.createElement("script")
          script.type = "text/javascript"
          script.src = "https://talk.hyvor.com/web-api/embed.js"

          discussions.replaceChildren(widget)
          document.body.appendChild(script)
        }
    </script>



</body></html>